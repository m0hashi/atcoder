{
    "MdoCom": {
        "scope": "cpp",
        "prefix": "lib/modCom",
        "body": [
            "struct ModCom{",
            "    int lim=1e7;",
            "    vector<mint> X;",
            "    void init(){",
            "        X.resize(lim+1);",
            "        X[0]=X[1]=1;",
            "        for(int i=1; i<=lim; i++)X[i]=i*X[i-1];",
            "    }",
            "    mint calc(int n, int k){",
            "        if(X.size()==0)init();",
            "        return X[n]*X[k].inv()*X[n-k].inv();",
            "    }",
            "};",
            "\n"
        ],
        "description": "./mod.cpp"
    },
    "sieveOfErathos": {
        "scope": "cpp",
        "prefix": "lib/sieveOfErathos",
        "body": [
            "vector<ll> sieveOfErathos(ll n){",
            "    vector<int> isPrime(n+1,1);",
            "    vector<ll> ret;",
            "    isPrime[0]=isPrime[1]=0;",
            "    for(ll p=2; p*p<=n; p++){",
            "        if(!isPrime[p])continue;",
            "        isPrime[p]=1;",
            "        for(ll j=2*p; j<=n; j+=p) isPrime[j]=0;",
            "    }",
            "    for(int i=2; i<=n; i++) if(isPrime[i]) ret.push_back(i);",
            "    return ret;",
            "}",
            "\n"
        ],
        "description": "./prime.cpp"
    },
    "primeFactorize": {
        "scope": "cpp",
        "prefix": "lib/primeFactorize",
        "body": [
            "vector<pair<ll,ll>> primeFactorize(ll n){",
            "    vector<pair<ll,ll>> ret;",
            "    ll div=2;",
            "    while(div*div<=n){",
            "        int count=0;",
            "        while(n%div==0){",
            "            n/=div;",
            "            count++;",
            "        }",
            "        ret.push_back({div, count});",
            "        div++;",
            "    }",
            "    if(n!=1) ret.push_back({n, 1});",
            "    return ret;",
            "}",
            "\n"
        ],
        "description": "./prime.cpp"
    },
    "floydWarshall": {
        "scope": "cpp",
        "prefix": "lib/floydWarshall_function",
        "body": [
            "template <typename T>",
            "vector<vector<T>> floydWarshall(const vector<vector<T>>& dist, const T INF) {",
            "    int n = dist.size();",
            "    vector<vector<T>> ret = dist;",
            "    for (int k = 0; k < n; k++) {",
            "        for (int i = 0; i < n; i++) {",
            "            for (int j = 0; j < n; j++) {",
            "                if (ret[i][k] == INF || ret[k][j] == INF) continue;",
            "                ret[i][j] = min(ret[i][j], ret[i][k] + ret[k][j]);",
            "            }",
            "        }",
            "    }",
            "    return ret;",
            "}",
            "\n"
        ],
        "description": "./FloydWarshall.cpp"
    },
    "DijkstraWithConstruction": {
        "scope": "cpp",
        "prefix": "lib/DijkstraWithConstruction",
        "body": [
            "struct Edge {",
            "    int id, from;",
            "    int to;",
            "    ll cost;",
            "    Edge(int f, int t, ll c, int i = 0) : from(f), to(t), cost(c), id(i) {}",
            "};",
            "\n",
            "struct Dijkstra {",
            "    ll INF = 1LL << 59;",
            "    vector<vector<Edge>> edge;",
            "    vector<ll> dist;",
            "    vector<pair<int, int>> from;",
            "    Dijkstra(int n) : edge(n), dist(n, INF), from(n, {-1, -1}) {}",
            "",
            "    void add_edge(int from, int to, ll cost, int id = 0) {",
            "        edge[from].emplace_back(from, to, cost, id);",
            "    }",
            "",
            "    vector<ll> run(int s) {",
            "        priority_queue<",
            "            tuple<ll, int, pair<int, int>>,  // dist, current_node, edge_id",
            "            vector<tuple<ll, int, pair<int, int>>>,",
            "            greater<tuple<ll, int, pair<int, int>>>>",
            "            q;",
            "        dist[s] = 0;",
            "        q.push({0, s, {-1, s}});",
            "        while (!q.empty()) {",
            "            auto [d, v, idx] = q.top();",
            "            q.pop();",
            "            if (d > dist[v]) continue;",
            "            rep(i, edge[v].size()) {",
            "                const Edge& e = edge[v][i];",
            "                if (chmin(dist[e.to], dist[v] + e.cost)) {",
            "                    q.push({dist[e.to], e.to, {v, i}});",
            "                    from[e.to] = {v, i};",
            "                }",
            "            }",
            "        }",
            "        return dist;",
            "    }",
            "",
            "    vector<Edge> construct_shortest_path(int t) {",
            "        vector<Edge> path;",
            "        for (int cur = t; cur != -1; cur = from[cur].first) {",
            "            auto [_s, _t] = from[cur];",
            "            if (_s != -1) path.push_back(edge[_s][_t]);",
            "        }",
            "        reverse(path.begin(), path.end());",
            "        return path;",
            "    }",
            "};",
            "\n"
        ],
        "description": "./DijkstraWithConstruction.cpp"
    },
    "Dijkstra": {
        "scope": "cpp",
        "prefix": "lib/Dijkstra",
        "body": [
            "struct Edge {",
            "    int id;",
            "    int to;",
            "    ll cost;",
            "    Edge(int t, ll c, int i = 0) : to(t), cost(c), id(i) {}",
            "};",
            "\n",
            "struct Dijkstra {",
            "    ll INF = 1LL << 59;",
            "    vector<vector<Edge>> edge;",
            "    vector<ll> dist;",
            "    Dijkstra(int n) : edge(n), dist(n, INF) {}",
            "",
            "    void add_edge(int from, int to, ll cost, int id = 0) {",
            "        edge[from].emplace_back(to, cost, id);",
            "    }",
            "",
            "    vector<ll> run(int s) {",
            "        priority_queue<",
            "            tuple<ll, int>,  // dist, current_node",
            "            vector<tuple<ll, int>>,",
            "            greater<tuple<ll, int>>",
            "            >q;",
            "        dist[s] = 0;",
            "        q.push({0, s});",
            "        while (!q.empty()) {",
            "            auto [d, v] = q.top();",
            "            q.pop();",
            "            if (d > dist[v]) continue;",
            "            rep(i, edge[v].size()) {",
            "                const Edge& e = edge[v][i];",
            "                if (chmin(dist[e.to], dist[v] + e.cost)) {",
            "                    q.push({dist[e.to], e.to});",
            "                }",
            "            }",
            "        }",
            "        return dist;",
            "    }",
            "};",
            "\n"
        ],
        "description": "./Dijkstra.cpp"
    },
    "dijkstra_function": {
        "scope": "cpp",
        "prefix": "lib/dijkstra_function",
        "body": [
            "vector<int> dijkstra(Graph& g, int s) {",
            "    pq_inv<pair<int, int>> pq;",
            "    vector<int> dist(g.size(), 1 << 30);",
            "    dist[s]=0;",
            "    pq.push({0, s});",
            "    while (!pq.empty()) {",
            "        auto [d, u] = pq.top();",
            "        pq.pop();",
            "        if(d>dist[u])continue;",
            "        for (auto&& e : g[u]) {",
            "            if (dist[e.to] <= d + e.cost) continue;",
            "            dist[e.to] = d + e.cost;",
            "            pq.push({dist[e.to], e.to});",
            "        }",
            "    }",
            "    return dist;",
            "}",
            "\n"
        ],
        "description": "./Dijkstra.cpp"
    },
    "UnionFind": {
        "scope": "cpp",
        "prefix": "lib/UnionFind",
        "body": [
            "struct UnionFind{",
            "    vector<int> par, siz;",
            "    UnionFind(int n): par(n,-1), siz(n,1){}",
            "    int root(int x){",
            "        if(par[x]==-1) return x;",
            "        // return root(par[x]);",
            "        return par[x]=root(par[x]);",
            "    }",
            "    bool is_same(int x, int y){",
            "        return root(x)==root(y);",
            "    }",
            "",
            "    bool merge(int x, int y){",
            "        x = root(x); y=root(y);",
            "        if(is_same(x,y)) return false;",
            "        if(y>x) swap(x,y);",
            "        par[y]=x;",
            "        siz[x]+=siz[y];",
            "        return true;",
            "    }",
            "    int size(int x){",
            "        return siz[root(x)];",
            "    }",
            "};",
            "\n"
        ],
        "description": "./UnionFind.cpp"
    },
    "Edge": {
        "scope": "cpp",
        "prefix": "lib/Edge",
        "body": [
            "struct Edge {",
            "    int id;",
            "    int to;",
            "    ll cost;",
            "    Edge(int t, ll c, int i = 0) : to(t), cost(c), id(i) {}",
            "};",
            "\n"
        ],
        "description": "./utils.cpp"
    },
    "Graph": {
        "scope": "cpp",
        "prefix": "lib/Graph",
        "body": [
            "struct Graph{",
            "    vector<vector<Edge>> edge;",
            "    Graph(int n): edge(n){}",
            "    void add_edge(int from, int to, int cost=1){",
            "        edge[from].emplace_back(to,cost);",
            "    }",
            "    vector<Edge>& operator [](int i){",
            "        return edge[i];",
            "    }",
            "    int size(){",
            "        return edge.size();",
            "    }",
            "};",
            "\n"
        ],
        "description": "./utils.cpp"
    },
    "ZobristHash": {
        "scope": "cpp",
        "prefix": "lib/ZobristHash",
        "body": [
            "template <typename T>",
            "struct ZobristHash {",
            "    random_device seed;",
            "    mt19937_64 engine;",
            "    uniform_int_distribution<long long> randint;",
            "    map<T, long long> hash_dict;",
            "    ZobristHash(): engine(seed()), randint(0,1LL<<63) {}",
            "",
            "    long long get_hash(const T key){",
            "        if (hash_dict.find(key)==hash_dict.end()){",
            "            hash_dict[key]=randint(engine);",
            "        }",
            "        return hash_dict[key];",
            "    }",
            "",
            "};",
            "\n"
        ],
        "description": "./zobristHash.cpp"
    },
    "ZobristHash_128": {
        "scope": "cpp",
        "prefix": "lib/ZobristHash_128",
        "body": [
            "template <typename T>",
            "struct ZobristHash_128 {",
            "    random_device seed;",
            "    mt19937_64 engine;",
            "    uniform_int_distribution<long long> randint;",
            "    map<T, __int128_t> hash_dict;",
            "    ZobristHash(): engine(seed()), randint(0,1LL<<63) {}",
            "",
            "    __int128_t get_hash(const T key){",
            "        if (hash_dict.find(key)==hash_dict.end()){",
            "            hash_dict[key]=(((__int128_t)randint(engine))<<63) + randint(engine);",
            "        }",
            "        return hash_dict[key];",
            "    }",
            "",
            "};",
            "\n"
        ],
        "description": "./zobristHash.cpp"
    },
    "LISWithConstruction": {
        "scope": "cpp",
        "prefix": "lib/LISWithConstruction",
        "body": [
            "vector<int> LISConstruction(vector<int>& A){",
            "\tvector<int>dp_val(A.size(),INTMAX);",
            "\tvector<int>len(A.size());",
            "\trep(i,(int)A.size()){",
            "\t\tint loc = lower_bound(dp_val.begin(), dp_val.end(), A[i]) - dp_val.begin();",
            "\t\tdp_val[loc] = A[i];",
            "\t\tlen[i] = loc+1; //Aiまでを利用してLISを構成したときの、Aiを末端とするLISの長さ",
            "\t}",
            "",
            "    //LISを構成する末端の要素をみつけて逆順に構成していく",
            "    vector<int> ret;",
            "    int end_pos = max_element(len.begin(), len.end()) - len.begin(); // argmax(len). LISを構成したときのLIS末端要素のAにおけるインデックス",
            "    int prev_len = len[end_pos];",
            "    int prev_val = A[end_pos];",
            "    for (int i = end_pos- 1; i >= 0; i--)",
            "    {",
            "        if(len[i]==prev_len-1  //末端からLIS末端の要素を確定させていくとき、末尾の要素が確定したLISより長さが1つ短いLISであり、かつその末端がAiであって",
            "            && A[i]<prev_val){ // 要素が確定したLISの末端よりA_iが小さい場合",
            "            ret.push_back(A[i]);",
            "            prev_val=A[i];",
            "            prev_len--;",
            "        }",
            "    }",
            "    return ret;",
            "}",
            "\n"
        ],
        "description": "./LIS.cpp"
    },
    "LIS": {
        "scope": "cpp",
        "prefix": "lib/LIS",
        "body": [
            "int LIS(vector<int>& A){",
            "\tvector<int>dp(A.size(),INTMAX);",
            "    // 各iを末端とするLISの構築",
            "\tvector<int>len(A.size());",
            "\trep(i,(int)A.size()){",
            "\t\tint loc = lower_bound(dp.begin(), dp.end(), A[i]) - dp.begin();",
            "\t\tdp[loc] = A[i];",
            "\t\tlen[i] = loc+1; //Aiまでを利用してLISを構成したときの、Aiを末端とするLISの長さ",
            "\t}",
            "    return *max_element(len.begin(), len.end());",
            "",
            "}",
            "\n"
        ],
        "description": "./LIS.cpp"
    },
    "Prim": {
        "scope": "cpp",
        "prefix": "lib/KruskalMST",
        "body": [
            "struct Edge {",
            "    int from;",
            "    int to;",
            "    ll cost;",
            "    Edge(int f, int t, ll c) :from(f), to(t), cost(c) {};",
            "    bool operator<(const Edge& e) const{ return cost < e.cost;}",
            "    bool operator>(const Edge& e) const{ return cost > e.cost;}",
            "};",
            "\n",
            "struct UnionFind {",
            "    vector<int> par, siz;",
            "    UnionFind(int n) : par(n, -1), siz(n) {}",
            "    int root(int x) {",
            "        if (par[x] == -1) return x;",
            "        // return root(par[x]);",
            "        return par[x] = root(par[x]);",
            "    }",
            "    bool is_same(int x, int y) {",
            "        return root(x) == root(y);",
            "    }",
            "",
            "    bool merge(int x, int y) {",
            "        x = root(x);",
            "        y = root(y);",
            "        if (is_same(x, y)) return false;",
            "        if (y > x) swap(x, y);",
            "        par[y] = x;",
            "        siz[x] += siz[y];",
            "        return true;",
            "    }",
            "    int size(int x) {",
            "        return siz[root(x)];",
            "    }",
            "};",
            "\n",
            "struct KruskalMST {",
            "    vector<Edge> edge;",
            "    vector<vector<Edge>> mst;",
            "    ll mst_cost=0;",
            "    KruskalMST(int n) : mst(n) {}",
            "",
            "    void add_edge(int from, int to, ll cost) {",
            "        edge.emplace_back(from, to, cost);",
            "    }",
            "",
            "    ll construct() {",
            "        ll total_cost = 0;",
            "        sort(edge.begin(), edge.end());",
            "        UnionFind uf(mst.size());",
            "        for(auto&& e:edge){",
            "            if(uf.is_same(e.from, e.to))continue;",
            "            uf.merge(e.from, e.to);",
            "            mst[e.from].emplace_back(e.from, e.to, e.cost);",
            "            mst[e.to].emplace_back(e.to, e.from, e.cost);",
            "            total_cost += e.cost;",
            "        }",
            "        return total_cost;",
            "    }",
            "};",
            "\n"
        ],
        "description": "./KruskalMST.cpp"
    }
}